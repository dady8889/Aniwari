@using System.Diagnostics;

@using Aniwari.BL.Interfaces;
@using Aniwari.BL.Messaging;
@using Aniwari.BL.Repositories;
@using Aniwari.BL.Services;
@using Aniwari.DAL.Schedule;
@using Aniwari.DAL.Storage;
@using Aniwari.DAL.Time;

@inherits ReactiveComponentBase

@inject IJSRuntime JS
@inject ISettingsService SettingsService
@inject ITorrentService TorrentService
@inject IAnimeRepository AnimeRepository

@if (Anime == null) return;

<Accordion @key="Anime.Id" PreventExpanding="editSearchString">
    <AccordionHeader>
        <div class="aniwari-list-item watchlist-item @(context.Expanded ? "expanded" : "")">
            @if (!editSearchString)
            {
                <div class="title-wrapper">
                    <div class="title" title="@Anime.SearchString">
                        @Anime.Title
                    </div>
                    <button class="title-button" @onclick:stopPropagation="true" @onclick="OnTitleClicked">
                        Edit
                    </button>
                </div>
            }
            else
            {
                <div class="title-wrapper">
                    <div @ref="searchStringFieldReference" class="searchstring-field" @onclick:stopPropagation="false" contenteditable="true">
                        @Anime.SearchString
                    </div>
                    <div class="button-wrapper">
                        <button class="title-button" @onclick:stopPropagation="true" @onclick="OnEditEnded">
                            Save
                        </button>
                        <button class="title-button" @onclick:stopPropagation="true" @onclick="OnResetClicked">
                            Reset
                        </button>
                    </div>
                </div>
            }
            <div class="episodes-counter">
                <div>
                    @Anime.GetWatchedEpisodes().Count()
                </div>
                <div>
                    /
                </div>
                <div>
                    @(Anime.EpisodesCount?.ToString() ?? "?")
                </div>
            </div>
        </div>
    </AccordionHeader>
    <AccordionBody>
        <div class="aniwari-list-detail">
            @if (Anime.EpisodesCount != null)
            {
                (Anime as ITimeConvertible).UpdateLocalTime();

                var maxEpId = Anime.EpisodesCount.Value;
                DateTime? aired = Anime.LocalAiredDate;

                if (aired != null)
                {
                    // the aired date can differ with the scheduled time
                    // we need to ignore this date and find the closest next day
                    // we are assuming that the next episode airs at least after 7 next days
                    DateTime dayAfterFirstAiring = aired.Value.Date.AddDays(7);

                    while (dayAfterFirstAiring.DayOfWeek != Anime.LocalScheduleDay)
                    {
                        dayAfterFirstAiring = dayAfterFirstAiring.AddDays(1);
                    }

                    var betweenAiredToNow = DateTime.Today - dayAfterFirstAiring;
                    var daysBetween = betweenAiredToNow.TotalDays;

                    // we are still waiting for second episode
                    if (daysBetween < 0)
                    {
                        maxEpId = 2;
                    }
                    else
                    {
                        maxEpId = (int)Math.Floor(daysBetween / 7) + 3;
                    }

                    // the anime has finished airing according to the current calendar
                    if (maxEpId > Anime.EpisodesCount.Value)
                    {
                        maxEpId = Anime.EpisodesCount.Value;
                    }
                }

                foreach (int epId in Enumerable.Range(1, maxEpId))
                {
                    <div class="aniwari-list-item episode">
                        <div class="episode__header">
                            <div class="episode__title">Episode @epId</div>
                            @{
                                DayOfWeek scheduleDay = DayOfWeek.Monday;
                                TimeOnly? scheduleTime = null;

                                if (SettingsService.GetStore().PreferredTime == PreferredTime.JST)
                                {
                                    scheduleDay = Anime.JSTScheduleDay;
                                    scheduleTime = Anime.JSTAirTime;
                                }
                                else if (SettingsService.GetStore().PreferredTime == PreferredTime.Local)
                                {
                                    scheduleDay = Anime.LocalScheduleDay;
                                    scheduleTime = Anime.LocalAirTime;
                                }
                            }
                            @if (scheduleTime != null && epId == maxEpId)
                            {
                                string day = scheduleDay.ToString();

                                if (scheduleDay == DateTime.Now.DayOfWeek)
                                {
                                    day = "Today";
                                }

                                <div class="episode__reminder">
                                    @day at @(scheduleTime.Value.ToString("HH:mm"))
                                </div>
                            }
                        </div>

                        @{
                            var ep = Anime.Episodes.FirstOrDefault(x => x.Id == epId);
                        }

                        @if (ep != null)
                        {
                            @if (!ep.Downloaded)
                            {
                                @if (!ep.Downloading)
                                {
                                    <div class="button-wrapper">
                                        <button class="episode__button" @onclick="() => OnDownloadClicked(ep)" title="@(ep.TorrentTitle)">
                                            Download
                                        </button>
                                        <button class="episode__button" @onclick="() => OnSearchClicked(epId)">
                                            Search
                                        </button>
                                    </div>
                                }
                                else
                                {
                                    <div>
                                        @ep.Progress
                                        %
                                    </div>
                                    <button class="episode__button" @onclick="() => OnCancelDownloadClicked(ep)">
                                        Cancel
                                    </button>
                                }
                            }
                            else
                            {
                                if (ep.Seeding)
                                {
                                    <div>
                                        @(ep.SeedRatio.ToString("0.###", System.Globalization.CultureInfo.InvariantCulture))
                                    </div>
                                }

                                <div class="button-wrapper">
                                    @if (ep.Seeding)
                                    {
                                        <button class="episode__button" @onclick="() => OnCancelSeedClicked(ep)">
                                            Stop seeding
                                        </button>
                                    }
                                    else
                                    {
                                        <button class="episode__button" @onclick="() => OnSeedClicked(ep)">
                                            Seed
                                        </button>
                                    }

                                    <button class="episode__button" @onclick="() => OnWatchClicked(ep)">
                                        Watch
                                    </button>
                                    <button class="episode__button" @onclick="() => OnDeleteClicked(ep)">
                                        Delete
                                    </button>
                                </div>
                            }
                        }
                        else
                        {
                            <button class="episode__button" @onclick="() => OnSearchClicked(epId)">
                                Search
                            </button>
                        }
                    </div>
                }
            }
        </div>
    </AccordionBody>
</Accordion>

@code {
    public record SearchEventArgs(Anime Anime, int Episode);

    [Parameter] public Anime? Anime { get; set; }
    [Parameter] public EventCallback<SearchEventArgs> OnSearch { get; set; }

    private IJSObjectReference? module;
    private ElementReference searchStringFieldReference;
    private bool editSearchString = false;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        module = await JS.InvokeAsync<IJSObjectReference>("import", "./Watchlist/WatchlistItem.razor.js");

        ReactTo<TorrentUpdated>(async (e) =>
        {
            if (e.AnimeId == Anime?.Id)
            {
                var episode = Anime.Episodes.FirstOrDefault(x => x.Id == e.EpisodeId);
                if (episode != null)
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        });

        ReactTo<TorrentFinished>(async (e) =>
        {
            if (e.AnimeId == Anime?.Id)
            {
                var episode = Anime.Episodes.FirstOrDefault(x => x.Id == e.EpisodeId);
                if (episode != null)
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        });

        ReactTo<TorrentErrored>(async (e) =>
        {
            if (e.AnimeId == Anime?.Id)
            {
                var episode = Anime.Episodes.FirstOrDefault(x => x.Id == e.EpisodeId);
                if (episode != null)
                {
                    await InvokeAsync(StateHasChanged);
                    // todo: show error
                }
            }
        });
    }

    private async Task OnSearchClicked(int episode)
    {
        if (OnSearch.HasDelegate && Anime != null)
            await OnSearch.InvokeAsync(new SearchEventArgs(Anime, episode));
    }

    private void OnTitleClicked()
    {
        editSearchString = true;
    }

    private async Task OnEditEnded()
    {
        Anime!.SearchString = await JS.InvokeAsync<string>("getElementInnerText", searchStringFieldReference);
        await SettingsService.SaveAsync();
        editSearchString = false;
    }

    private async Task OnDownloadClicked(Episode episode)
    {
        string archivePath = SettingsService.GetStore().ArchivePath;

        episode.Downloading = true;

        await TorrentService.DownloadAnime(Anime!.Id, episode.Id, episode.TorrentMagnet, archivePath);
    }

    private void OnWatchClicked(Episode episode)
    {
        var archivePath = SettingsService.GetStore().ArchivePath;
        var videoPath = Path.Combine(archivePath, episode.VideoFilePath);

        if (File.Exists(videoPath))
        {
            using Process process = new()
                {
                    StartInfo = new(videoPath)
                    {
                        UseShellExecute = true
                    }
                };

            process.Start();
        }
    }

    private async Task OnDeleteClicked(Episode episode)
    {
        if (episode.Seeding)
        {
            await TorrentService.CancelSeed(Anime!.Id, episode.Id);
            episode.Seeding = false;
        }

        var archivePath = SettingsService.GetStore().ArchivePath;
        var videoPath = Path.Combine(archivePath, episode.VideoFilePath);

        if (File.Exists(videoPath))
            File.Delete(videoPath);

        AnimeRepository.RemoveEpisode(Anime!, episode);
        await SettingsService.SaveAsync();
    }

    private void OnResetClicked()
    {
        Anime!.SearchString = $"{Anime!.Title} @ep";
    }

    private async Task OnCancelDownloadClicked(Episode episode)
    {
        var file = await TorrentService.CancelDownload(Anime!.Id, episode.Id);
        if (file != null)
        {
            var archivePath = SettingsService.GetStore().ArchivePath;
            var videoPath = Path.Combine(archivePath, file);

            if (File.Exists(videoPath))
                File.Delete(videoPath);
        }

        episode.Progress = 0;
        episode.Downloading = false;
        episode.Downloaded = false;
        episode.VideoFilePath = string.Empty;

        StateHasChanged();

        await SettingsService.SaveAsync();
    }

    private async Task OnCancelSeedClicked(Episode episode)
    {
        await TorrentService.CancelSeed(Anime!.Id, episode.Id);
        episode.Seeding = false;

        StateHasChanged();

        await SettingsService.SaveAsync();
    }

    private async Task OnSeedClicked(Episode episode)
    {
        await OnDownloadClicked(episode);
    }
}
